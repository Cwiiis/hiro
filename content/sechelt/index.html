<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Sechelt</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>

	<body>
		<script src="js/three.min.js"></script>

		<script src="js/FirstPersonControls.js"></script>

		<script src="js/VRControls.js"></script>
		<script src="js/VREffect.js"></script>

		<script src="js/C4DLineLoader.js"></script>

		<script src="../../js/vrclient.js"></script>

		<script>

			var camera, scene, renderer;
			var controls, effect;

			var controls2, clock = new THREE.Clock();

			var sky, water;

			var cameraPath;

			var loader = new THREE.C4DLineLoader();
			loader.load( 'flightpath.txt', function ( line ) {

				cameraPath = line; 

			} );

			init();
			animate();
			VRClient.ready().then(function() {
				console.log('kicked off ready');
			});

			function init() {

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.autoClear = false;
				renderer.setClearColor( 0x404040 );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0xcacfde, 0, 1000 );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.set( 500, 500, 500 );

				controls2 = new THREE.FirstPersonControls( camera );
				controls2.movementSpeed = 1000;
				controls2.lookSpeed = 0;
				controls2.lookVertical = false;

				effect = new THREE.VREffect( renderer );
				controls = new THREE.VRControls( camera );

				document.body.addEventListener( 'dblclick', function () {

					effect.setFullScreen( true );

				} );

				// skybox

				var geometry = new THREE.SphereGeometry( 1000, 64, 32 );

				var vertices = geometry.vertices;
				var faces = geometry.faces;

				var colorTop = new THREE.Color( 0xdc72aa );
				var colorMiddle = new THREE.Color( 0xfbdfd3 );
				var colorBottom = new THREE.Color( 0xd7b8b2 );

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					var vertex1 = vertices[ face.a ];
					var vertex2 = vertices[ face.b ];
					var vertex3 = vertices[ face.c ];

					var color1 = colorMiddle.clone();
					color1.lerp( vertex1.y > 0 ? colorTop : colorBottom, Math.abs( vertex1.y ) / 2000 );

					var color2 = colorMiddle.clone();
					color2.lerp( vertex2.y > 0 ? colorTop : colorBottom, Math.abs( vertex2.y ) / 2000 );

					var color3 = colorMiddle.clone();
					color3.lerp( vertex3.y > 0 ? colorTop : colorBottom, Math.abs( vertex3.y ) / 2000 );

					face.vertexColors.push( color1, color2, color3 );

				}

				var material = new THREE.MeshBasicMaterial( {
					vertexColors: THREE.VertexColors,
					side: THREE.BackSide,
					depthWrite: false,
					depthTest: false,
					fog: false
				} );

				sky = new THREE.Mesh( geometry, material );
				scene.add( sky );

				var geometry = new THREE.Geometry();

				var vertices = geometry.vertices;
				var faces = geometry.faces;

				var vector = new THREE.Vector3();

				for ( var i = 0; i < 10000; i ++ ) {

					vector.x = Math.random() * 2000 - 1000;
					vector.z = Math.random() * 2000 - 1000;

					var size = Math.random() * 2 + 1;
					var angle = Math.random() * Math.PI;

					var vertex1 = vector.clone();
					vertex1.x += size * Math.cos( angle );
					vertex1.z += size * Math.sin( angle );

					angle -= 2;

					var vertex2 = vector.clone();
					vertex2.x += size * Math.cos( angle );
					vertex2.z += size * Math.sin( angle );

					angle -= 2;

					var vertex3 = vector.clone();
					vertex3.x += size * Math.cos( angle );
					vertex3.z += size * Math.sin( angle );

					var a = vertices.push( vertex1 ) - 1;
					var b = vertices.push( vertex2 ) - 1;
					var c = vertices.push( vertex3 ) - 1;

					faces.push( new THREE.Face3( a, b, c ) );

				}

				var material = new THREE.MeshBasicMaterial( { opacity: 0.4, transparent: true } )

				var mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				/*
				// water

				var geometry = new THREE.PlaneBufferGeometry( 100000, 100000 );
				var material = new THREE.MeshBasicMaterial( {
					color: colorMiddle,
					opacity: 0.75,
					transparent: true
				} );
				water = new THREE.Mesh( geometry, material );
				water.position.y = 40;
				water.rotation.x = - Math.PI / 2;
				scene.add( water );
				*/

				//

				var loader = new THREE.ObjectLoader();
				loader.load( 'scene.json', function ( object ) {

					var landscape = object.getObjectByName( 'lanscape' );

					var reflection = new THREE.Mesh( landscape.geometry, landscape.material.clone() );
					reflection.material.color.setHex( 0xdac5c9 );
					reflection.material.side = THREE.BackSide;
					reflection.position.y = 7.7;
					reflection.scale.y = -1;
					landscape.parent.add( reflection );

					scene.add( object );

				} );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {

				if ( cameraPath !== undefined ) {

					var time = performance.now() / 50000;

					var pointA = cameraPath.getPointAt( time % 1 );
					var pointB = cameraPath.getPointAt( ( time + 0.01 ) % 1 );

					pointA.z = -pointA.z;
					pointB.z = -pointB.z;

					camera.position.copy( pointA );
					camera.lookAt( pointB );
					
					// camera.position.multiplyScalar( 0.75 );
					// camera.position.multiplyScalar( 0.001 );
					// camera.position.x += 589.94;
					// camera.position.y += 1377;
					// camera.position.z += 21602;

				}

				// controls2.update( clock.getDelta() );
				controls.update();

				sky.position.copy( camera.position );

				/*
				water.position.x = camera.position.x;
				water.position.z = camera.position.z;
				*/

				effect.render( scene, camera );

			}

		</script>

	</body>
</html>
